\documentclass[12pt]{article}

\usepackage{tabularx}
\usepackage[a4paper,margin=2.5cm, bottom=4cm]{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{float}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[table]{xcolor}

\graphicspath{{../img/}}

\setlength{\headheight}{40pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}
\renewcommand{\headrulewidth}{0pt}

\newcommand{\subfiguresize}{.3\textwidth}

\lstset {
    basicstyle = \small\ttfamily,
}

\begin{document}

\pagestyle{fancy}
\fancyhead[L]{
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\textwidth}{|X|X|}
        \hline
        \large \bf Image processing & \normalsize Task No. 1 \\
        \hline
    \end{tabularx}
}
\fancyfoot[C]{\thepage}

\thispagestyle{empty}
\renewcommand{\arraystretch}{2}
\begin{flushleft}
    \begin{tabularx}{0.95\textwidth}{|X|X|}
        \hline
        \bf \large Image Processing                   & \bf \large Task No.~1                           \\ \hline
        \multicolumn{2}{|l|}{
            \textbf{Task variant:} Group 1
        }                                                                                               \\ \hline
        \textbf{Day and time:} Mon, 14:00             & \textbf{Full name:} \textsc{Jakub Pawlak}       \\
        \textbf{Academic year: 3\textsuperscript{rd}} & \textbf{Full name:} \textsc{Magdalena Paku\l a} \\
        \hline
    \end{tabularx}
\end{flushleft}
\vspace{1em}
\renewcommand{\arraystretch}{1}

\section*{Technical description of the program}
\subsection*{Basic information}

Technical description of the application
This application allows a user to apply some operations to bitmap files, which are:
\begin{enumerate}
    \item basic color correction operations such as modifying brightness or contrast
    \item geometric operations, for example resizing or flipping the image
    \item noise removal filters (in this case median and geometric mean)
\end{enumerate}
We decided to write our project in the Rust programming language due to its multiple advantages, such as:
high speed due to it being compiled language like C++, yet with much more safety mechanisms for managing memory without the use of a garbage collector.

To view the instructions of usage, the user should invoke the program with ``\lstinline{--help}'' argument.
This will print all of the available operations, including the arguments that the user should provide.
The basic format for all the operations are:
\begin{center}
    \lstinline{executable --command [-argument=value]* input_file}
\end{center}

\subsection*{Advanced information}
\subsubsection*{Used libraries}
The external libraries (called ``crates'' in case of Rust) that we use in our project are
\begin{itemize}
    \item \textbf{image} --- providing implementations of image encoders and decoders,
          used for reading and saving the images
    \item \textbf{vulkano} --- Rust wrapper around the Vulkan graphical API,
          which we use to provide alternative implementations of some transformations,
          which are run on the GPU making them significantly faster
\end{itemize}

\subsubsection*{Data structures}
For storing the image we use RgbImage struct from the mentioned image crate,
which is just a wrapper around a vector of pixels, which in turn are just a 3-element array of unsigned 8-bit integers (one for each RGB channel).

\section*{Description of implementation of basic image operations}

\paragraph*{Preface on the used notation}
In the equations we write to describe operations, we will use luminosity functions $f$ to describe the original image, and $\hat{f}$ to describe the new image (after transformation).
$f(x,y)$ will denote the luminosity of the pixel at the coordinates $x,y$. Unless explicitly stated, the method will be the same for each color channel.
For brevity, if the pixel coordinates are irrelevant, they may be ommited and be assumed to be the same for $\hat{f}$ and $f$, i.e.\ $\hat{f}=f$ is equivalent to $\hat{f}(x,y) = f(x,y)$.
Additionally, we define $x|_{[a,b]}$ as $x$ restricted to the range $[a,b]$, that is $\max\{a, \min\{x,b\}\}$.
For parameters that are specified by the user (e.g\ in brightness or contrast modifications), we will use letters from the greek alphabet.

\subsection*{Brightness modification (B1)}

\begin{equation}
    \hat{f} = (f + \alpha) \, \Big|_{[0,255]}
\end{equation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_bright+30.png}
        \caption{with increased brightness}
    \end{subfigure}
    \caption{Image before and after increasing the brightness by 30}
\end{figure}

\subsection*{Contrast modification (B2)}

\begin{equation}
    \hat{f} = \left((f - 128) \cdot \alpha + 128\right)\Big|_{[0,255]}
\end{equation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_contrast_2x.png}
        \caption{with increased contrast}
    \end{subfigure}
    \caption{Image before and after increasing the contrast by a factor of 2}
\end{figure}

\subsection*{Negative (B3)}

\begin{equation}
    \hat{f} = 255 - f
\end{equation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_negative.png}
        \caption{negative}
    \end{subfigure}
    \caption{Image before and after inverting the colors}
\end{figure}

\subsection*{Horizontal flip (G1)}

\begin{equation}
    \hat{f}(x,y) = f(width - x, y)
\end{equation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_hflip.png}
        \caption{flipped}
    \end{subfigure}
    \caption{Image before and after flipping it horizontally}
\end{figure}

\subsection*{Vertical flip (G2)}

\begin{equation}
    \hat{f}(x,y) = f(x, height - y)
\end{equation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_vflip.png}
        \caption{flipped}
    \end{subfigure}
    \caption{Image before and after flipping it vertically}
\end{figure}

\subsection*{Diagonal flip (G3)}

\begin{equation}
    \hat{f}(x,y) = f(width - x, height - y)
\end{equation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_dflip.png}
        \caption{flipped}
    \end{subfigure}
    \caption{Image before and after flipping it diagonally}
\end{figure}

\subsection*{Shrink (G4) and Enlarge (G5)}

For shrinking and enlarging, we will implement just one transformation, called scale.
Given some factors $\varphi_x, \varphi_y$ and an image with dimensions $w \times h$, it will produce a new image of dimensions $\varphi_x w \times \varphi_y h$.

\begin{equation}
    \hat{f}(x,y) =
    f\left(
    \left\lfloor
    \frac{x}{\varphi_x}
    \right\rfloor,
    \left\lfloor
    \frac{y}{\varphi_y}
    \right\rfloor
    \right)
\end{equation}

Although our function allows for different scaling factors
in the $x$ and $y$ dimensions,
the user is only able to input one value $\varphi$,
to preserve the original image aspect ratio,
so the program just sets $\varphi_x = \varphi_y = \varphi$.

Enlarge will just apply scale with the factor as it is, and shrink will apply scale, but with the inverse of the specified factor,
i.e.\ if we want to shrink by a factor of 2, we will apply scale with a factor of $\frac{1}{2}$.


\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac.png}
        \caption{original ($512 \times 512$)}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=.7\textwidth]{lenac_small.png}
        \caption{shrunk ($128 \times 128$)}
    \end{subfigure}
    \caption{Image before and after shrinking by a factor of 4 (not to scale)}
\end{figure}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=.7\textwidth]{lenac_small.png}
        \caption{original ($128 \times 128$)}
    \end{subfigure}
    \hspace{.05\textwidth}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{lenac_enlarged.png}
        \caption{enlarged ($512 \times 512$)}
    \end{subfigure}
    \caption{Image before and after enlarging by a factor of 4 (not to scale)}
\end{figure}

\section*{Description of the implementation of the noise reduction methods}

\subsection*{Common implementation}
We noticed that all the filters operate by gathering some neighbourhood around the target pixel,
and then applying some reducing function on that pixels to determine the value of the resulting pixel.
Therefore, in order to remove duplication, we extracted the common functionality of gathering the pixels to a separate function $collect\_pixels$, such that:

\begin{equation*}
    collect\_pixels : \mathbf{Ref}\langle\mathrm{Image}\rangle \times \mathbb{N}^4 \to \mathbf{Multiset}\langle \mathbf{Ref}\langle\mathrm{Pixel} \rangle\rangle
\end{equation*}

Note that we return the pixels by read-only reference, so we are not performing unnecessary copies.

Let $Img$ denote some image, and $Img_{(x,y)}$ the pixel of $Img$ at coordinates $x,y$.
Let $w$ and $h$ be width and height of $Img$. 
Then, $collect\_pixels(Img,x,y,r_x,r_y)$ will return the pixels of $Img$ in some neighbourhood $S_{(x,y)}$ around $(x,y)$, defined as follows:
\begin{equation}
    S_{(x,y)} = 
    \\\bigg\{
        Img_{(x,y)} \mid x \in [x-r_x,x+r_x] \cap [0,w) \land y \in [y-r_y, y+r_y] \cap [0,h)
    \bigg\}
\end{equation}

\begin{lstlisting}
let mut neighbourhood: Vec<&Rgb<u8>> = Vec::new();
for x in u32::saturating_sub(x, x_offset)..=(x + x_offset) {
    for y in u32::saturating_sub(y, y_offset)..=(y + y_offset) {
        if x < image.width() && y < image.height() {
            neighbourhood.push(image.get_pixel(x, y));
        }
    }
}
\end{lstlisting}


\subsection*{Median filter}




\end{document}