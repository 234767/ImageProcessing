\documentclass[12pt]{article}

\input{../prelude.tex}
\graphicspath{{../img_task2/}}

\title{Task No.~2}

\begin{document}
\maketitle

\section{Description of the implementation of \texorpdfstring{\\ }{} histogram-based image enhancement method}
Histogram based image enhancements work by assigning new values to the luminosity levels, to match the histogram to some function.
The old luminosities will be denoted as $f$, and the new ones, as $g$.
The histogram of the image is denoted as $H$, and $H(f)$ means the number of pixels with luminosity $f$.
Finally, $N$ will mean the total number of pixels in the image.

\subsection{Mathematical description}

The equation for calculating the new luminosity values were given as:
\begin{equation}
    g(f) = g_{min} +\sqrt{
        2 \alpha^2 \cdot \ln\left[
            \left(
            \frac{1}{N} \sum\limits_{k=0}^f H(k)
            \right)^{-1}
            \right]
    }
    \label{eq:rayleigh-initial}
\end{equation}

We immediately noticed, that the numer under the logarithm is a partial sum of the normalized histogram values for luminosities smaller or equal $f$.
We can refactor the equation, by introducing a partial sum function $ps(f)$:
\begin{equation}
    ps(f) = \sum\limits_{k=0}^f H(f)
\end{equation}

Equation (\ref{eq:rayleigh-initial}) then takes form:
\begin{equation}
    g(f) = g_{min} + \sqrt{
        2 \alpha^2 \cdot \ln
        \left(
        \frac{N}{ps(f)}
        \right)}
\end{equation}

Note that,
\(
\bigforall_{f \in \langle f_{min},f_{max}\rangle} : 0 < ps(f) \leq N
\), and $ps(f)$ is monotinically non-decreasing.
That means that $\frac{N}{ps(f)}$ is monotinically non-increasing, and as follows, $g(f)$ is also non-increasing.

However, this is not what we want from image transformation, as it would produce a negative image.
Therefore, we flip the function horizontally, by changing the sign of $ps(f)$, and offseting it by $N$, to keep the domain the same.

\begin{equation}
    g(f) = g_{min} + \sqrt{
        2 \alpha^2 \cdot \ln
        \left(
        \frac{N}{N - ps(f) + 1}
        \right)}
    \label{eq:rayleigh-corrected}
\end{equation}
Now, as $f$ increases, $g(f)$ will increase as well.

However, the value of $\alpha$ is still unknown.
We know, that the function $g(f)$ should map $f$ to $g$ in such a way, that
$f_{min} \mapsto g_{min}$ and $f_{max} \mapsto g_{max}$.

For the first case:
\(
\lim\limits_{f \to f_{min}} ps(f) = 1
\),which means that
\(
\lim\limits_{f \to f_{min}} g(f) = g_{min}
\) regardless of $\alpha$.

The second case is more interesting:
\begin{align*}
    ps(f_{max}) & = N                \\[1ex]
    g(f_{max})  & = g_{min} + \sqrt{
        2 \alpha^2 \cdot \ln(N)
    }
\end{align*}
Substituting $g(f_{max}) = g_{max}$,
\begin{align}
    g_{max} & = g_{min} + \sqrt{
        2 \alpha^2 \cdot \ln(N)
    }\nonumber                                                                     \\[1ex]
    g_{max} & = g_{min} + \alpha \cdot \sqrt{2\ln(N)} \nonumber                    \\[1ex]
    \alpha  & = \frac{g_{max} - g_{min}}{\sqrt{2\ln(N)}} \label{eq:rayleigh-alpha}
\end{align}

\subsection{Implementation}

We start, by calculating the partial sums of the histogram for each channel:
\begin{lstlisting}
let partial_sums: [[u32; 256]; 3] = {
        let histogram = Histogram::new(image);
        histogram
            .into_iter()
            .map(|h| {
                h.iter()
                    .scan(0u32, |sum, value| {
                        *sum += value;
                        Some(*sum)
                    })
                    .collect()
            })
            .collect::<Vec<[u32; 256]>>()
            .try_into()
            .unwrap()
    };
\end{lstlisting}

\pagebreak[2]
Then, we calculate the image size, and the value of $\alpha$, according to eq. (\ref{eq:rayleigh-alpha})
\begin{lstlisting}
let image_size = image.width() * image.height();
let alpha = (self.gmax - self.gmin) as f64 
    / f64::sqrt(2.0 * f64::ln(image_size as f64));
\end{lstlisting}

\pagebreak[2]
Then, we create the brighness lookup table, according to eq. (\ref{eq:rayleigh-corrected}):
\begin{lstlisting}[basicstyle = \footnotesize\ttfamily]
let mut brightness_lookup = [[0u8; 256]; 3];
for channel in 0..3 {
    for i in 0..256 {
        let partial_sum = partial_sums[channel][i];
        if partial_sum == 0 {
            continue;
        }
        let log_base = 
            image_size as f64 / (image_size - partial_sum + 1) as f64;
        let root_base = 
            2.0 * alpha * alpha * f64::ln(log_base);
        brightness_lookup[channel][i] = 
            self.gmin
            + f64::clamp(
                f64::sqrt(root_base), 
                0.0, 
                (self.gmax - self.gmin) as f64) as u8;
        if partial_sums[channel][i] == image_size {
            break;
        }
    }
}
\end{lstlisting}

Note 2 important things --- the \lstinline{continue} and \lstinline{break} statements inside the loop.
We are interested in filling the lookup table only for values of $f \in \langle f_{min}, f_{max} \rangle$.
Therefore, we check if $ps(f) = 0$. If it is, then $f < f_{min}$, and we need not perform the calculation, so we continue looping
until we encounter some $ps(f) > 0$.

Similarly, we do not need to perform calculations for $f > f_{max}$. We know that $ps(f) = N \Leftrightarrow f \geq f_{max}$,
so if we reach that point, we do not need to perform any calculations for further values of $f$, and can safely break out of the loop.

This is a small optimization compensating for the fact that we cannot create a smaller lookup table, adjusted to the size of $\langle f_{min}, f_{max}\rangle$, because these values are unknown at compile time.

\pagebreak[2]
Finally, we set the new luminosity levels in the image according to the created lookup table:
\begin{lstlisting}
for pixel in image.pixels_mut() {
    for channel in 0..3 {
        let luminosity = pixel[channel];
        let new_luminosity = 
            brightness_lookup[channel][luminosity as usize];
        pixel[channel] = new_luminosity
    }
}
\end{lstlisting}


\section{Image analysis on the basis of the histogram}

\section{Description of the linear filter implementation (general formulation)}

\section{Description of the linear filter implementation (with optimization)}

\section{Analysis of the filtering results (linear filter)}

\section{Description of the non-linear filter implementation }

\section{Analysis of the filtering results (non-linear filter)}

\section{Description of other changes which took place in the application}



\vfill
\section*{Teacher's remarks}
\begin{tabularx}{\textwidth}{|X|}
    \hline
    \vspace{7cm}
    \phantom{.} \\
    \hline
\end{tabularx}

\end{document}