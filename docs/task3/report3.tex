\documentclass[12pt]{article}

\input{../prelude.tex}
\renewcommand{\subfiguresize}{.25\textwidth}
\graphicspath{{img},{../img}}

\usetikzlibrary{matrix}
\tikzset{square matrix/.style={
    matrix of nodes,
    nodes in empty cells,
    column sep=-\pgflinewidth, row sep=-\pgflinewidth,
    nodes={draw,
      minimum height=#1,
      anchor=center,
      text width=#1,
      align=center,
      inner sep=0pt
    },
  },
  square matrix/.default=1.5em
}

\title{Task No.~3}

\begin{document}
\maketitle

\section{Description of the implementation of the basic \texorpdfstring{\\ }{} morphological operations}

\subsection*{Optimization}

To make operations on binary images more efficient,
we represent the binary mask not as an image or collection of coordinates,
but as a slice of memory where each bit corresponds to a specific pixel.
This is done to firstly reduce the memory size, and secondly to make the operations faster by enabling the use of
binary operators, which are $\mathcal{O}(1)$.

Since the mask is a finite cartesian coordinate plane, we can assign each point $(x,y)$,
a unique number $n = x + wy$, where $w$ is the width of the coordinate plane.
The pixel will be assigned the $n$-th bit.

Therefore, for a $3\times3$ mask, it will be represented in the following way

\begin{center}
    \begin{tikzpicture}[baseline=(Center.base)]
        \matrix[square matrix]
        {
        |[fill=gray]| & |[fill=gray]| & \\
        & |(Center)[fill=gray]| & \\
        & & |[fill=gray]| \\
        };
    \end{tikzpicture}
    $\; \Longleftrightarrow \; (100010011)_2$
\end{center}

\vfill

However, since the input is in the image form, we need a function to convert between the image and binary representations.
This function will take the image, as well as a set of $(x,y)$ coordinates, and construct the mask from the pixels neighboring $(x,y)$.

\begin{equation}
    \mathbf{M}(A,x,y) \to B
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(Center.base)]
        \matrix[square matrix]
        {
        |[fill=gray]|&&|[fill=gray]|&&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]| & |[fill=gray]| && \\
        && |(Center)[fill=gray]|{$\bullet$} && \\
        && & |[fill=gray]| &|[fill=gray]| \\
        &|[fill=gray]|&|[fill=gray]|&&|[fill=gray]|\\
        };
    \end{tikzpicture}
    $\; \mapsto \; $
    \begin{tikzpicture}[baseline=(Center.base)]
        \matrix[square matrix]
        {
        |[fill=gray]| & |[fill=gray]| & \\
        & |(Center)[fill=gray]| & \\
        & & |[fill=gray]| \\
        };
    \end{tikzpicture}
\end{center}

\vfill
\pagebreak[2]

\begin{lstlisting}
pub fn from_image(image: &GrayImage, x: u32, y: u32) -> Mask {
    let mut mask = Mask::new();
    for i in 0..3 {
        for j in 0..3 {
            if is_unwritable(image, x, y, i, j) {
                continue;
            }
            mask.set_pixel(
                i, 
                j, 
                image.get_pixel(x + i - 1, y + j - 1)
            );
        }
    }
    mask
}
\end{lstlisting}

\vspace{2em}
We have also implemented the reverse function,
to set the pixels in the image from the binary implementation.

\begin{lstlisting}
pub fn write_to_image(
    &self, 
    image: &mut GrayImage, 
    x: u32, 
    y: u32
) {
    for i in 0..3 {
        for j in 0..3 {
            if is_unwritable(image, x, y, i, j) {
                continue;
            }
            image.put_pixel(
                x + i - 1, 
                y + j - 1, 
                self.get_pixel(i, j)
            );
        }
    }
}
\end{lstlisting}

Note that this function,
will overwrite the existing pixels if they are foreground in image,
but background in mask.

\pagebreak[4]
\subsection{Dilation}

The dilation of a binary image $A$ by a binary mask $B$ is defined as
\begin{equation}
    A \oplus B = \bigcup_{a \in A} B_a
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&\\
        &|(A)[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&\\
        };
    \end{tikzpicture}
    $\; \oplus \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        & |[fill=gray]| & \\
        & |[fill=gray]|$\odot$ & \\
        & &  \\
        };
    \end{tikzpicture}
    $\; = \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &|[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&\\
        };
    \end{tikzpicture}
\end{center}

To calculate the dilation of image $A$ by mask $B$,
we first need to allocate a new image $A'$.
This is done, because the dilation operating on more than one pixel,
so we cannot corrupt the original data.

Then, for each pixel $(x,y) \in A$, if $A(x,y)$ is foreground,
we perform the folliwing steps:
\begin{enumerate}
    \item Convert the neighbourhood of $(x,y)$ from $A'$ to binary mask $B'$
    \item Apply the binary or operation to the acquired mask and the mask $B$
    \item Save the result to the image $A'$
\end{enumerate}

\begin{lstlisting}
for (x, y, pixel) in image.enumerate_pixels() {
    if !is_foreground(pixel) {
        continue;
    }
    let new_image_mask = Mask::from_image(&new_image, x, y);
    let mask = self.mask | new_image_mask;
    mask.write_to_image(&mut new_image, x, y);
}
\end{lstlisting}

\subsection{Erosion}

Erosion of $A$ by $B$ is defined as
\begin{equation}
    A \ominus B = \left\{ (x,y) \mid B_{(x,y)} \subseteq A \right\}
    \label{eq:erosion-formal-def}
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&|[fill=gray]|\\
        &|(A)[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&\\
        };
    \end{tikzpicture}
    $\; \ominus \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        & |[fill=gray]| & \\
        & |[fill=gray]|$\odot$ & \\
        & &  \\
        };
    \end{tikzpicture}
    $\; = \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&\\
        &&|[fill=gray]|\\
        &|[fill=gray]|&\\
        };
    \end{tikzpicture}
\end{center}

We can check the condition that $B_{(x,y)} \subseteq A$ very easily by usin the binary and operation.
\begin{equation}
    B_{(x,y)} \subseteq A \;\Leftrightarrow\; B = \left( B \land \mathbf{M}(A,x,y) \right)
\end{equation}

\pagebreak[2]
We can thus rewrite eq. (\ref{eq:erosion-formal-def}) as:
\begin{equation}
    A \ominus B = \left\{ (x,y) \mid B = \big( B \land \mathbf{M}(A,x,y) \big) \right\}
\end{equation}


Therefore, to calculate $A \ominus B$, for each $(x,y) \in A$, we perform the following steps:
\begin{enumerate}
    \item Convert the neighbourhood of $(x,y)$ from $A$ to binary form
    \item Apply the binary and operation to the acquired mask and the mask $B$
    \item If the result of the prevous step is equal to $B$, we set $A'(x,y)$ to foreground
\end{enumerate}

\pagebreak[3]
\begin{lstlisting}
for (x, y, pixel) in image.enumerate_pixels() {
    let mask = self.mask & Mask::from_image(&image, x, y);
    if mask == self.mask {
        new_image.put_pixel(x, y, FOREGROUND_PIXEL);
    }
}
\end{lstlisting}

\subsection{Opening}
An opening morphological operation can be implemented by adding a new method to the Dilation struct that performs an erosion operation on the image before applying the dilation. The erosion operation removes small elements from the image, while the dilation operation expands the remaining elements. The representation of this operation as mathematical equation is below.

\begin{equation}
   A \circ B  = ( A \ominus B )\oplus B
\end{equation}

Below is the implementation we used in the project.
\begin{lstlisting}
impl MorphologicalTransform for Opening {
    fn apply_morph_operation(&self, image: &mut GrayImage) {
        self.erosion.apply_morph_operation(image);
        self.dilation.apply_morph_operation(image);
    }
}
\end{lstlisting}
The Opening struct has two fields, dilation and erosion, which are instances of the Dilation and Erosion structs, respectively.

\subsection{Closing}

The closing operation is performed by first dilating the image and then eroding it. This has the effect of "closing" small gaps or holes within an object, and can be useful for smoothing out noise or filling in small defects in an image. It can also be used to extract specific features from an image, such as blobs or connected components, by removing small, isolated pixels or structures that do not contribute to the overall shape of the object.The representation of this operation as mathematical equation is below.

\begin{equation}
   A \bullet B  = ( A \oplus B )\ominus B
\end{equation}

Below is the implementation we used in the project.
\begin{lstlisting}
impl MorphologicalTransform for Closing {
    fn apply_morph_operation(&self, image: &mut GrayImage) {
    	self.dilation.apply_morph_operation(image);
        self.erosion.apply_morph_operation(image);
    }
}
\end{lstlisting}

The Closing struct has two fields, dilation and erosion, which are instances of the Erosion and Dilation structs, respectively.
\subsection{Hit-or-miss transform}

The HMT of $A$ with $\mathbf{B}$ where $\mathbf{B} = (B_{hit},B_{miss})$, is defined as
\begin{equation}
    A \otimes \mathbf{B} = \left\{ p \mid \biggerforall\limits_{\substack{b_{hit} \in B_{hit} \\ b_{miss} \in B_{miss}}}\; p + b_{hit} \in A \land p + b_{miss} \notin A  \right\}
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&|[fill=gray]|&&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        &|[fill=gray]|&|(A)[fill=gray]|&|[fill=gray]|&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        &&&&\\
        };
    \end{tikzpicture}
    $\; \ominus \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        & |[fill=green]| & \\
        & $\odot$ & |[fill=red]| \\
        & &|[fill=red]|  \\
        };
    \end{tikzpicture}
    $\; = \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&&&\\
        &&&&\\
        &&&|[fill=gray]|&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        };
    \end{tikzpicture}
\end{center}

However, for our implementation, we will use the following property:
\begin{equation}
    A \otimes \mathbf{B} = (A \ominus B_1) \cap (A^C \ominus B_2)
\end{equation}

Which we can rewrite to make use of the binary operators as the following:

\begin{equation}
    A \otimes \mathbf{B} = \left\{ (x,y) \mid
    \Big(B_1 = \big(B_1 \land \mathbf{M}(A,x,y)\big)\Big)
    \land \Big( B_2 = \big( B_2 \land \neg \mathbf{M}(A,x,y) \big) \Big)
    \right\}
\end{equation}

The core of our HMT transform implementation is a helper function \lstinline{get_matching_pixels}, which operates on an iterator.
It takes a reference to the image, and outputs the $(x,y)$ coordinates of the pixels that fullfill the conditions of the HMT.

We could just use a for-loop and check the condition inside of it, however,
a helper function operating on an iterator will prove to be very useful when implementing the convex hull in section \ref{sec:convex-hull-impl}.

The function is implemented in the following way:

\begin{lstlisting}
pub(crate) fn get_matching_pixels<'img, 's, 'out>(
    &'s self,
    image: &'img GrayImage,
) -> impl Iterator<Item = (u32, u32)> + 'out
where
    'img: 'out,
    's: 'out
{
    image
      .enumerate_pixels()
      .map(|(x, y, _)| (x, y)) // discard the pixel reference
      .filter(|(x, y)| {
          let img_mask = &Mask::from_image(image, *x, *y);
          let is_hit = 
            self.hit_mask == (&self.hit_mask & img_mask);
          let is_miss = 
            self.miss_mask == (&self.miss_mask & &(!img_mask));  
          
          is_hit && is_miss
      })
}
\end{lstlisting}

\begin{remark}
    Although the function signature might look a bit intimidating due to annotations such as \lstinline{'img}, \lstinline{'s}, and \lstinline{'out},
    it is actually very straightforward.
    These are so-called \emph{lifetime annotations} that helps the rust compiler ensure the memory safety at compile time.
    Since the function result operates on the data from the image, and the HMT struct holding the structring elements,
    we have to constraint the lifetime of the result, such that the HMT struct and the image both have to be valid for at least
    as long as the result of the function.
\end{remark}

Finally, the implementation of the HMT is very straightforward, we just allocate a buffer for the new image
and set all the pixels that match the HMT conditions as foreground.

\begin{lstlisting}
let mut new_image: GrayImage = /* ... */
for (x, y) in self.get_matching_pixels(image) {
    new_image.put_pixel(x, y, FOREGROUND_PIXEL);
}
*image = new_image;
\end{lstlisting}

\pagebreak[2]
\section{Analysis of the results of the basic morphological operations}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &&\\
            &|[fill=gray]|$\odot$&|[fill=gray]|\\
            &&\\
            };
        \end{tikzpicture}
        \caption{$B_1$}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &&\\
            &|[fill=gray]|$\odot$&\\
            &|[fill=gray]|&\\
            };
        \end{tikzpicture}
        \caption{$B_2$}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            |[fill=gray]|&|[fill=gray]|&|[fill=gray]|\\
            |[fill=gray]|&|[fill=gray]|$\odot$&|[fill=gray]|\\
            |[fill=gray]|&|[fill=gray]|&|[fill=gray]|\\
            };
        \end{tikzpicture}
        \caption{$B_3$}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &|[fill=gray]|&\\
            |[fill=gray]|&|[fill=gray]|$\odot$&|[fill=gray]|\\
            &|[fill=gray]|&\\
            };
        \end{tikzpicture}
        \caption{$B_4$}
    \end{subfigure}
    \caption{Kernels used for testing}
\end{figure}

\subsection{Dilation}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-dilation-b1.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-dilation-b1.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of applying dilation with kernel $B_1$}
\end{figure}   

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-dilation-b2.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-dilation-b2.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of applying dilation with kernel $B_1$}
\end{figure}  

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-dilation-8adj.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-dilation-8adj.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of applying dilation with kernel $B_3$}
\end{figure}    

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-dilation-4adj.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-dilation-4adj.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of applying dilation with kernel $B_4$}
\end{figure} 

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat.png}}
        \caption{original}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-dilation-b1.png}}
        \caption{$B_1$}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-dilation-b2.png}}
        \caption{$B_2$}
    \end{subfigure}\\[1em]
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-dilation-b3.png}}
        \caption{$B_3$}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-dilation-b4.png}}
        \caption{$B_4$}
    \end{subfigure}
    \hspace{2em}
    \caption{Results of applying dilation on the boat image}
\end{figure} 

\subsection{Erosion}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-erosion-b1.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-erosion-b1.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of erosion dilation with kernel $B_1$}
\end{figure} 

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-erosion-b2.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-erosion-b2.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of erosion dilation with kernel $B_2$}
\end{figure} 

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-erosion-8adj.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-erosion-8adj.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of erosion dilation with kernel $B_3$}
\end{figure} 

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image1-erosion-4adj.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/image2-erosion-4adj.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of erosion dilation with kernel $B_4$}
\end{figure} 

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat.png}}
        \caption{original}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-erosion-b1.png}}
        \caption{$B_1$}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-erosion-b2.png}}
        \caption{$B_2$}
    \end{subfigure}\\[1em]
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-erosion-b3.png}}
        \caption{$B_3$}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \fbox{\includegraphics[width=.9\textwidth]{img/boat-erosion-b4.png}}
        \caption{$B_4$}
    \end{subfigure}
    \hspace{2em}
    \caption{Results of applying erosion on the boat image}
\end{figure} 

\subsection{Opening}
\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/boatbw.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/output1.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/girlbw.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/output2.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of applying opening operation}
\end{figure}  

\subsection{Closing}
\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/boatbw.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/output3.png}
        \caption{after}
    \end{subfigure}\\[1em]
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/girlbw.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}\centering
        \includegraphics[width=\textwidth]{img/magda/output4.png}
        \caption{after}
    \end{subfigure}
    \caption{Results of applying closing operation}
\end{figure}  

\subsection{Hit-or-miss transform}

\section{Description of the implementation of the assigned variant of morphological algorithm}

\subsection{Description}
The algorithm we had to implement is the convex hull.

It is used to eliminate any concavities from the shape.
The calculation of a convex hull of some image $A$ works as follows:

For each structuring element $\mathbf{B}^i$ from elements shown on fig. \ref{fig:convex-hull-kernels},
we repeatedly apply the HMT, until there is no change.

For calculating the subsequent iterations of applying the HMTs, we have formula
\begin{equation}
    X^i_k = (X^i_{k-1} \otimes \mathbf{B}^i) \cup A
    \label{eq:convex-hull-iteration-err}
\end{equation}
Our starting condition is
\begin{equation}
    X^i_0 = A
    \label{eq:convex-hull-start-condition}
\end{equation}
We apply equation (\ref*{eq:convex-hull-iteration-err}) until we find the smallest $k$ such that:
\begin{equation}
    X^i_k = X^i_{k-1}
    \label{eq:convex-hull-final-condition}
\end{equation}

When we reach the final condition, we yield the result $X^i_k$ as $D^i$.

The final result of the computation is the union of all $D^i$ for all $i$.

\begin{figure}[H]\centering
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            |[fill=green]|&&\\
            |[fill=green]|&|[fill=red]|$\odot$&\\
            |[fill=green]|&&\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^1$}
        \label{kernel-convex-left}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            |[fill=green]|&|[fill=green]|&|[fill=green]|\\
            &|[fill=red]|$\odot$&\\
            &&\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^2$}
        \label{kernel-convex-up}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &&|[fill=green]|\\
            &|[fill=red]|$\odot$&|[fill=green]|\\
            &&|[fill=green]|\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^3$}
        \label{kernel-convex-right}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &&\\
            &|[fill=red]|$\odot$&\\
            |[fill=green]|&|[fill=green]|&|[fill=green]|\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^4$}
        \label{kernel-convex-down}
    \end{subfigure}
    \caption{Structuring elements used for convex hull}
    \label{fig:convex-hull-kernels}
\end{figure}

\pagebreak[3 ]
\subsection*{The error in the formula}

If the task was to be followed exactly as given in the instruction, it would not yield the desired result.
To be precise, for all $\mathbf{B}^i$ in fig. \ref{fig:convex-hull-kernels}, for any image $A$:
\begin{equation*}
    (A \otimes \mathbf{B}^i) \neq \emptyset \implies \mbox{\large$\mathsurround0pt\nexists$} D^i
\end{equation*}

\begin{proof}
    In all of the structuring elements in fig.~\ref{fig:convex-hull-kernels}, the origin (marked $\odot$) is marked as `miss', meaning, that it must not be present in the original image.
    As a consequence of that:
    \begin{equation}
        \biggerforall\nolimits_i\biggerforall\nolimits_k \; X^i_k \cap (X^i_k \otimes \mathbf{B}^i) = \emptyset
        \label{eq:convex-hull-disjoint-hmt}
    \end{equation}

    Now, if we substitute the final condition (\ref{eq:convex-hull-final-condition}) to eq.~(\ref{eq:convex-hull-iteration-err}), we get:
    \begin{equation}
        X^i_k = (X^i_k \otimes \mathbf{B}^i) \cup A
        \label{eq:convex-hull-iteration-error-substituted}
    \end{equation}

    Applying $X = X \cap X$, we get
    \begin{align}
        X^i_k & = X^i_k \cap \big((X^i_k \otimes \mathbf{B}^i) \cup A \big) \nonumber    \\
              & = \big(X^i_k \cap (X^i_k \otimes \mathbf{B}^i) \big) \cup (X^i_k \cap A)
    \end{align}

    Applying eq.~(\ref{eq:convex-hull-disjoint-hmt})
    \begin{align}
        X^i_k & = \emptyset \cup (X^i_k \cap A) \nonumber \\
              & = X^i_k \cap A \nonumber                  \\
              & = A \label{eq:convex-hull-only-zero-k}
    \end{align}
    Which is the same as eq.~(\ref{eq:convex-hull-start-condition}), so $k=0$.\\
    Finally, substituting this equation to eq.~(\ref{eq:convex-hull-iteration-error-substituted}), we get
    \begin{equation}
        A = (A \otimes \mathbf{B}^i) \cup A
    \end{equation}

    Which is true if and only if $(A \otimes \mathbf{B}^i) \subseteq A$.\\
    Since $(A \otimes \mathbf{B}^i) \subseteq A$ and from eq.~\eqref{eq:convex-hull-disjoint-hmt}, $(A \otimes \mathbf{B}^i) \cap A = \emptyset$, we have:
    \begin{equation}
        (A \otimes \mathbf{B}^i) = \emptyset
    \end{equation}
    Therefore,
    \begin{align*}
        \bigexists k                              & \iff (A \otimes \mathbf{B}^i) = \emptyset    \\
        \mbox{\large$\mathsurround0pt\nexists$} k & \iff (A \otimes \mathbf{B}^i) \neq \emptyset
    \end{align*}
    Since $\nexists k \Rightarrow \nexists D^i$, we have
    \begin{equation}
        (A \otimes \mathbf{B}^i) \neq \emptyset \implies \mbox{\large$\mathsurround0pt\nexists$} D^i
    \end{equation}
\end{proof}

As the above shows, there are two possibilities of running the algorithm:
\begin{enumerate}
    \item If $\bigforall_i \; (A \otimes \mathbf{B}^i) = \emptyset$, then all $k = 0$ and algorith returns the original image unchanged
    \item Else, the algorithm gets stuck in the infinite loop trying to find $k$ that does not exist
\end{enumerate}

Therefore, we concluded that for the algorithm to work as expected, we must change the eq.~\eqref{eq:convex-hull-iteration-err} to the following:
\begin{equation}
    X^i_k = (X^i_{k-1} \otimes \mathbf{B}^i) \cup X^i_{k-1}
\end{equation}

Now, $k$ will always exist, and it will be such $k$ that $(X^i_k \otimes \mathbf{B}^i) = \emptyset$.

\pagebreak[2]
\subsection{Implementation}
\label{sec:convex-hull-impl}

The implementation can be split into 2 distinct parts.
The first one is calculating $D^i$ for a given $\mathbf{B}^i$.
We will refer to this step as ``saturating'' the image with the hit-or-miss transformation.
The second step is merging all of the resulting images into one.

With standard implementation, we would have to loop over the entire image to calculate the HMT.
Then, we would need to loop again to perform the image union with $X^i_{k-1}$.
This would have to be performed $k$ times for each structuring element.
Finally we would have to loop over the entire image once again to merge all of $D^i$.

However, we are able to perform major optimization by removing the need of applying the union altogether.
We can acomplish this by, instead of using standard HMT, making use of the abovementioned function that returns an iterator to all of the pixels that fullfill the HMT conditions.
We do this by not allocating a clear image buffer for the output of HMT, but instead output the result directy to the image in place.
This firstly, reduces the number of operations significantly, and secondly, drastically reduces the memory complexity, as we will not allocate any aditional buffers.

This also applies to union of $D^i$, because we can redefine the initial conditions from eq.~\eqref{eq:convex-hull-final-condition} as the following:
\begin{equation*}
    X^i_0 =
    \begin{cases}
        A       & \text{for $i = 0$}, \\
        D^{i-1} & \text{for $i > 0$}
    \end{cases}
\end{equation*}

\pagebreak[2]
Below is our implementation of this algorithm:
\begin{lstlisting}
for (hit, miss) in &STRUCTURAL_ELEMENTS {
    let transform = 
        HitOrMissTransform::new(hit.clone(), miss.clone());

    loop {
        let transform_result: Vec<_> = 
            transform.get_matching_pixels(image).collect();
        if transform_result.len() == 0 {
            break;
        }
        for (x, y) in transform_result {
            image.put_pixel(x, y, FOREGROUND_PIXEL);
        }
    }
}
\end{lstlisting}

\section{Analysis of the results of the assigned variant of morphological algorithm}

The results of applying the convex hull are presented below:

\begin{figure}[h]\centering
    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image1-convexhull.png}
        \caption{after}
    \end{subfigure}\\[2em]

    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image2-convexhull.png}
        \caption{after}
    \end{subfigure}
    \caption{Result of applying the convex hull}
\end{figure}

As we can see, the convex hull worked as expected, eliminating any concavities in the input shape.
It procuded a diagonal rectangle, completely containing the original shape.
The downside of the algorithm is that it often outputs more pixels that are actually needed for the shape to be convex.

For testing we chose custom shapes, prepared in such a way, that has a diagonal skeleton, while the other has an orthogonal one.
The algorithm yielded much better result for the othogonal-based shape, 
because it outputs less unnecessary pixels.

This behaviour is to be expected, because the choice of the structuring elements on fig. \ref{fig:convex-hull-kernels}, 
is such, that the algorithm will expand the shape in the orthogonal directions.
Therefore, the resulting shape will be rectangle composed of $45^\circ$-rotated lines.

As a consequence, the dimensions of output shape will be dictated by the maximum taxicab distance from the corners of the image.

That is, let $C$ be the set of the corners of an image:
\begin{equation*}
    C = \big\{ (0,0),\, (x_{max},0),\, (y_{max},0),\, (x_{max},y_{max}) \big\}
\end{equation*}
Then, if $A$ is the image before applying convex hull, and $A'$ is after:
\begin{equation*}
    \biggerforall_{(x_0,y_0) \in C} \;
    \max\limits_{(x,y) \in A}\Big\{ |x - x_0| + |y - y_0| \Big\} = \max\limits_{(x,y) \in A'} \Big\{ |x - x_0| + |y - y_0| \Big\}
\end{equation*}

Therefore, although the diagonal and orthogonal shapes have the similar dimensions in the sense of euclidean geometry,
in taxicab distance, the orthogonal shape will have much smaller dimensions, and thus, much smaller dovex hull.

If, however, instead of structuring elements from fig. \ref{fig:convex-hull-kernels}, 
we used such elements, that the image would expand diagonally, thus producing convex hull in the shape of an orthogonal rectangle,
we would find that the dimensions of the hull are determined by the dimensions of the shape in terms of the chebyshev distance,
thus yielding better results for the diagonal shape.

\section{Description of the implementation of the assigned segmentation variant}
\subsection{Description}
Region growing is a type of image segmentation technique that is used to identify and separate different objects or regions within an image. It works by starting from a seed point within an image and then iteratively expanding the region by adding adjacent pixels that meet certain criteria, such as being within a certain range of intensity or color.

To perform region growing, the image is first divided into a set of small, connected regions, or seeds. Each seed represents a potential region within the image, and the algorithm starts by selecting one of these seeds as the starting point for region growing. The algorithm then compares the values of the pixels in the seed to the values of the pixels in the surrounding area. If the values of the surrounding pixels meet certain criteria, such as being within a certain range of intensity or color, they are added to the growing region. This process is repeated until all adjacent pixels have been examined, at which point the region is complete.

Region growing is useful for separating objects or regions within an image that have similar characteristics, such as intensity or color. It is a popular technique in image processing because it is relatively simple to implement and can be used to segment images of various types, including binary, grayscale, and color images.

Our implementation uses a breadth-first search algorithm to expand the region from the seed point. It maintains a queue of pixels to visit and adds the neighboring pixels of each pixel to the queue if they have a similar intensity value to the seed point, within a specified tolerance. The resulting image is a binary image with the region of interest marked in white and the rest of the image marked in black.

\subsection{Implementation}

In our implementation, \lstinline{seed_x} and \lstinline{seed_y} represent the $x$ and $y$ coordinates respectively,
of the seed point in the image chosen by the user.
The seed point is also the starting point for the region growing algorithm.
The \lstinline{tolerance} is also chosen by the user.
Firstly, we are checking whether the chosen pixel is within the dimensions of the input image.
If the seed point is within the image dimensions,
the transformation for region growing can be performed.
Below the implementation of the \lstinline{Transformation} trait for \lstinline{RegionGrowing}:

\begin{lstlisting}
    
/* ensure seed_x and seed_y are within image */

let mut new_image: GrayImage = 
    ImageBuffer::new(image.width(), image.height());
let seed_pixel = 
    image.get_pixel(self.seed_x.get(), self.seed_y.get());
let mut queue = VecDeque::new();
queue.push_back((self.seed_x.get(), self.seed_y.get()));

while let Some((x, y)) = queue.pop_front() {
    if x >= image.width() || y >= image.height() {
        continue;
    }
    let pixel = image.get_pixel(x as u32, y as u32);
    let new_image_pixel = new_image.get_pixel(x as u32, y as u32);

    if new_image_pixel[0] == 0 
        && is_similar(pixel, seed_pixel, self.tolerance) {
        new_image.put_pixel(x as u32, y as u32, Luma([255]));

        queue.push_back((x + 1, y));
        queue.push_back((x, y + 1));
        queue.push_back((x - 1, y));
        queue.push_back((x, y - 1));
    }
}
*image = DynamicImage::from(new_image).to_rgb8();
\end{lstlisting}

The \lstinline{is_similar} function was implemented by taking in a reference to a pixel
and a reference to a seed pixel,
as well as a tolerance value.
It calculates the difference between the value of the pixel
and the seed pixel and returns true if the difference is less than or equal
to the tolerance value. Below the implementation of the \lstinline{is_similar} function:

\begin{lstlisting}
fn is_similar(
    pixel: &Rgb<u8>, 
    seed_pixel: &Rgb<u8>, 
    tolerance: u8
) -> bool {
    (pixel[0] as i32 - seed_pixel[0] as i32) <= tolerance as i32
}
\end{lstlisting}

\section{Analysis of the results of the assigned segmentation variant}
\section{Description of other changes which took place in the application}

Using the console interface proved to be very tedious to use for a long time,
especially with repeated transformations and long filepaths.
Additionally, to view the results, we would have to save to external file and open it every time.

To make things more easy to use, we started work on a graphical user interface for our project.

This was pretty straightforward to set up, as all of our image operations were in form of a static library, 
decoupled from the console interface. 
Thus, it was just a matter of creating another binary with a reference to our image operations.

For the framework, we decided to try Tauri (see \href{https://tauri.app/about/intro}{tauri webpage}), which is similar to elecron, with the key difference that has better performance, and smaller executable size.
The backend code is written in Rust, and consists mostly of calling our image operations library,
and the frontend is done using Svelte (see \href{https://svelte.dev}{svelte webpage}) with typescript.

So far, we were only able to implement some of the transformations from the previous tasks,
but with some free time we might expand the functionality in the future.

\begin{figure}[H]\centering
    \includegraphics[width=.8\textwidth]{gui_screenshot.png}
    \caption{Graphical user interface for our image processing application}
\end{figure}

\end{document}