\documentclass[12pt]{article}

\input{../prelude.tex}
\graphicspath{{img},{../img}}

\usetikzlibrary{matrix}
\tikzset{square matrix/.style={
    matrix of nodes,
    nodes in empty cells,
    column sep=-\pgflinewidth, row sep=-\pgflinewidth,
    nodes={draw,
      minimum height=#1,
      anchor=center,
      text width=#1,
      align=center,
      inner sep=0pt
    },
  },
  square matrix/.default=1.5em
}

\title{Task No.~3}

\begin{document}
\maketitle

\section{Description of the implementation of the basic \texorpdfstring{\\ }{} morphological operations}

\subsection*{Optimization}

To make operations on binary images more efficient,
we represent the binary mask not as an image or collection of coordinates,
but as a slice of memory where each bit corresponds to a specific pixel.
This is done to firstly reduce the memory size, and secondly to make the operations faster by enabling the use of
binary operators, which are $\mathcal{O}(1)$.

Since the mask is a finite cartesian coordinate plane, we can assign each point $(x,y)$,
a unique number $n = x + wy$, where $w$ is the width of the coordinate plane.
The pixel will be assigned the $n$-th bit.

Therefore, for a $3\times3$ mask, it will be represented in the following way

\begin{center}
    \begin{tikzpicture}[baseline=(Center.base)]
        \matrix[square matrix]
        {
        |[fill=gray]| & |[fill=gray]| & \\
        & |(Center)[fill=gray]| & \\
        & & |[fill=gray]| \\
        };
    \end{tikzpicture}
    $\; \Longleftrightarrow \; (100010011)_2$
\end{center}

\vfill

However, since the input is in the image form, we need a function to convert between the image and binary representations.
This function will take the image, as well as a set of $(x,y)$ coordinates, and construct the mask from the pixels neighboring $(x,y)$.

\begin{equation}
    \mathbf{M}(A,x,y) \to B
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(Center.base)]
        \matrix[square matrix]
        {
        |[fill=gray]|&&|[fill=gray]|&&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]| & |[fill=gray]| && \\
        && |(Center)[fill=gray]|{$\bullet$} && \\
        && & |[fill=gray]| &|[fill=gray]| \\
        &|[fill=gray]|&|[fill=gray]|&&|[fill=gray]|\\
        };
    \end{tikzpicture}
    $\; \mapsto \; $
    \begin{tikzpicture}[baseline=(Center.base)]
        \matrix[square matrix]
        {
        |[fill=gray]| & |[fill=gray]| & \\
        & |(Center)[fill=gray]| & \\
        & & |[fill=gray]| \\
        };
    \end{tikzpicture}
\end{center}

\vfill
\pagebreak[2]

\begin{lstlisting}
pub fn from_image(image: &GrayImage, x: u32, y: u32) -> Mask {
    let mut mask = Mask::new();
    for i in 0..3 {
        for j in 0..3 {
            if is_unwritable(image, x, y, i, j) {
                continue;
            }
            mask.set_pixel(
                i, 
                j, 
                image.get_pixel(x + i - 1, y + j - 1)
            );
        }
    }
    mask
}
\end{lstlisting}

\vspace{2em}
We have also implemented the reverse function,
to set the pixels in the image from the binary implementation.

\begin{lstlisting}
pub fn write_to_image(
    &self, 
    image: &mut GrayImage, 
    x: u32, 
    y: u32
) {
    for i in 0..3 {
        for j in 0..3 {
            if is_unwritable(image, x, y, i, j) {
                continue;
            }
            image.put_pixel(
                x + i - 1, 
                y + j - 1, 
                self.get_pixel(i, j)
            );
        }
    }
}
\end{lstlisting}

Note that this function,
will overwrite the existing pixels if they are foreground in image,
but background in mask.

\pagebreak[4]
\subsection{Dilation}

The dilation of a binary image $A$ by a binary mask $B$ is defined as
\begin{equation}
    A \oplus B = \bigcup_{a \in A} B_a
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&\\
        &|(A)[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&\\
        };
    \end{tikzpicture}
    $\; \oplus \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        & |[fill=gray]| & \\
        & |[fill=gray]|$\odot$ & \\
        & &  \\
        };
    \end{tikzpicture}
    $\; = \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &|[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&\\
        };
    \end{tikzpicture}
\end{center}

To calculate the dilation of image $A$ by mask $B$,
we first need to allocate a new image $A'$.
This is done, because the dilation operating on more than one pixel,
so we cannot corrupt the original data.

Then, for each pixel $(x,y) \in A$, if $A(x,y)$ is foreground,
we perform the folliwing steps:
\begin{enumerate}
    \item Convert the neighbourhood of $(x,y)$ from $A'$ to binary mask $B'$
    \item Apply the binary or operation to the acquired mask and the mask $B$
    \item Save the result to the image $A'$
\end{enumerate}

\begin{lstlisting}
for (x, y, pixel) in image.enumerate_pixels() {
    if !is_foreground(pixel) {
        continue;
    }
    let new_image_mask = Mask::from_image(&new_image, x, y);
    let mask = self.mask | new_image_mask;
    mask.write_to_image(&mut new_image, x, y);
}
\end{lstlisting}

\subsection{Erosion}

Erosion of $A$ by $B$ is defined as
\begin{equation}
    A \ominus B = \left\{ (x,y) \mid B_{(x,y)} \subseteq A \right\}
    \label{eq:erosion-formal-def}
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&|[fill=gray]|\\
        &|(A)[fill=gray]|&|[fill=gray]|\\
        |[fill=gray]|&|[fill=gray]|&\\
        };
    \end{tikzpicture}
    $\; \ominus \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        & |[fill=gray]| & \\
        & |[fill=gray]|$\odot$ & \\
        & &  \\
        };
    \end{tikzpicture}
    $\; = \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&\\
        &&|[fill=gray]|\\
        &|[fill=gray]|&\\
        };
    \end{tikzpicture}
\end{center}

We can check the condition that $B_{(x,y)} \subseteq A$ very easily by usin the binary and operation.
\begin{equation}
    B_{(x,y)} \subseteq A \;\Leftrightarrow\; B = \left( B \land \mathbf{M}(A,x,y) \right)
\end{equation}

\pagebreak[2]
We can thus rewrite eq. (\ref{eq:erosion-formal-def}) as:
\begin{equation}
    A \ominus B = \left\{ (x,y) \mid B = \big( B \land \mathbf{M}(A,x,y) \big) \right\}
\end{equation}


Therefore, to calculate $A \ominus B$, for each $(x,y) \in A$, we perform the following steps:
\begin{enumerate}
    \item Convert the neighbourhood of $(x,y)$ from $A$ to binary form
    \item Apply the binary and operation to the acquired mask and the mask $B$
    \item If the result of the prevous step is equal to $B$, we set $A'(x,y)$ to foreground
\end{enumerate}

\pagebreak[3]
\begin{lstlisting}
for (x, y, pixel) in image.enumerate_pixels() {
    let mask = self.mask & Mask::from_image(&image, x, y);
    if mask == self.mask {
        new_image.put_pixel(x, y, FOREGROUND_PIXEL);
    }
}
\end{lstlisting}

\subsection{Opening}
An opening morphological operation can be implemented by adding a new method to the Dilation struct that performs an erosion operation on the image before applying the dilation. The erosion operation removes small elements from the image, while the dilation operation expands the remaining elements. The representation of this operation as mathematical equation is below.

\begin{equation}
    A \ominus B = \left\{ (x,y) \mid B = \big( B \land \mathbf{M}(A,x,y) \big) \right\}
\end{equation}

Below is the implementation we used in the project.
\begin{lstlisting}
impl MorphologicalTransform for Opening {
    fn apply_morph_operation(&self, image: &mut GrayImage) {
        self.erosion.apply_morph_operation(image);
        self.dilation.apply_morph_operation(image);
    }
}
\end{lstlisting}
The Opening struct has two fields, dilation and erosion, which are instances of the Dilation and Erosion structs, respectively.

\subsection{Closing}

\subsection{Hit-or-miss transform}

The HMT of $A$ with $\mathbf{B}$ where $\mathbf{B} = (B_{hit},B_{miss})$, is defined as
\begin{equation}
    A \otimes \mathbf{B} = \left\{ p \mid \biggerforall\limits_{\substack{b_{hit} \in B_{hit} \\ b_{miss} \in B_{miss}}}\; p + b_{hit} \in A \land p + b_{miss} \notin A  \right\}
\end{equation}

\begin{center}
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&|[fill=gray]|&&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        &|[fill=gray]|&|(A)[fill=gray]|&|[fill=gray]|&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        &&&&\\
        };
    \end{tikzpicture}
    $\; \ominus \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        & |[fill=green]| & \\
        & $\odot$ & |[fill=red]| \\
        & &|[fill=red]|  \\
        };
    \end{tikzpicture}
    $\; = \; $
    \begin{tikzpicture}[baseline=(A.base)]
        \matrix[square matrix]
        {
        &&&&\\
        &&&&\\
        &&&|[fill=gray]|&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        &|[fill=gray]|&&|[fill=gray]|&\\
        };
    \end{tikzpicture}
\end{center}

However, for our implementation, we will use the following property:
\begin{equation}
    A \otimes \mathbf{B} = (A \ominus B_1) \cap (A^C \ominus B_2)
\end{equation}

Which we can rewrite to make use of the binary operators as the following:

\begin{equation}
    A \otimes \mathbf{B} = \left\{ (x,y) \mid
    \Big(B_1 = \big(B_1 \land \mathbf{M}(A,x,y)\big)\Big)
    \land \Big( B_2 = \big( B_2 \land \neg \mathbf{M}(A,x,y) \big) \Big)
    \right\}
\end{equation}

The core of our HMT transform implementation is a helper function \lstinline{get_matching_pixels}, which operates on an iterator.
It takes a reference to the image, and outputs the $(x,y)$ coordinates of the pixels that fullfill the conditions of the HMT.

We could just use a for-loop and check the condition inside of it, however,
a helper function operating on an iterator will prove to be very useful when implementing the convex hull in section \ref{sec:convex-hull-impl}.

The function is implemented in the following way:

\begin{lstlisting}
pub(crate) fn get_matching_pixels<'img, 's, 'out>(
    &'s self,
    image: &'img GrayImage,
) -> impl Iterator<Item = (u32, u32)> + 'out
where
    'img: 'out,
    's: 'out
{
    image
      .enumerate_pixels()
      .map(|(x, y, _)| (x, y)) // discard the pixel reference
      .filter(|(x, y)| {
          let img_mask = &Mask::from_image(image, *x, *y);
          let is_hit = 
            self.hit_mask == (&self.hit_mask & img_mask);
          let is_miss = 
            self.miss_mask == (&self.miss_mask & &(!img_mask));  
          
          is_hit && is_miss
      })
}
\end{lstlisting}

\begin{remark}
    Although the function signature might look a bit intimidating due to annotations such as \lstinline{'img}, \lstinline{'s}, and \lstinline{'out},
    it is actually very straightforward.
    These are so-called \emph{lifetime annotations} that helps the rust compiler ensure the memory safety at compile time.
    Since the function result operates on the data from the image, and the HMT struct holding the structring elements,
    we have to constraint the lifetime of the result, such that the HMT struct and the image both have to be valid for at least
    as long as the result of the function.
\end{remark}

Finally, the implementation of the HMT is very straightforward, we just allocate a buffer for the new image
and set all the pixels that match the HMT conditions as foreground.

\begin{lstlisting}
let mut new_image: GrayImage = /* ... */
for (x, y) in self.get_matching_pixels(image) {
    new_image.put_pixel(x, y, FOREGROUND_PIXEL);
}
*image = new_image;
\end{lstlisting}

\pagebreak[2]
\section{Analysis of the results of the basic morphological operations}

\section{Description of the implementation of the assigned variant of morphological algorithm}

\subsection{Description}
The algorithm we had to implement is the convex hull.

It is used to eliminate any concavities from the shape.
The calculation of a convex hull of some image $A$ works as follows:

For each structuring element $\mathbf{B}^i$ from elements shown on fig. \ref{fig:convex-hull-kernels},
we repeatedly apply the HMT, until there is no change.

For calculating the subsequent iterations of applying the HMTs, we have formula
\begin{equation}
    X^i_k = (X^i_{k-1} \otimes \mathbf{B}^i) \cup A
    \label{eq:convex-hull-iteration-err}
\end{equation}
Our starting condition is
\begin{equation}
    X^i_0 = A
    \label{eq:convex-hull-start-condition}
\end{equation}
We apply equation (\ref*{eq:convex-hull-iteration-err}) until we find the smallest $k$ such that:
\begin{equation}
    X^i_k = X^i_{k-1}
    \label{eq:convex-hull-final-condition}
\end{equation}

When we reach the final condition, we yield the result $X^i_k$ as $D^i$.

The final result of the computation is the union of all $D^i$ for all $i$.

\begin{figure}[H]\centering
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            |[fill=green]|&&\\
            |[fill=green]|&|[fill=red]|$\odot$&\\
            |[fill=green]|&&\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^1$}
        \label{kernel-convex-left}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            |[fill=green]|&|[fill=green]|&|[fill=green]|\\
            &|[fill=red]|$\odot$&\\
            &&\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^2$}
        \label{kernel-convex-up}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &&|[fill=green]|\\
            &|[fill=red]|$\odot$&|[fill=green]|\\
            &&|[fill=green]|\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^3$}
        \label{kernel-convex-right}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}\centering
        \begin{tikzpicture}
            \matrix[square matrix]
            {
            &&\\
            &|[fill=red]|$\odot$&\\
            |[fill=green]|&|[fill=green]|&|[fill=green]|\\
            };
        \end{tikzpicture}
        \caption{$\mathbf{B}^4$}
        \label{kernel-convex-down}
    \end{subfigure}
    \caption{Structuring elements used for convex hull}
    \label{fig:convex-hull-kernels}
\end{figure}

\pagebreak[3 ]
\subsection*{The error in the formula}

If the task was to be followed exactly as given in the instruction, it would not yield the desired result.
To be precise, for all $\mathbf{B}^i$ in fig. \ref{fig:convex-hull-kernels}:
\begin{equation*}
    (A \otimes \mathbf{B}^i) \neq \emptyset \implies \mbox{\large$\mathsurround0pt\nexists$} D^i
\end{equation*}

\begin{proof}
    In all of the structuring elements in fig.~\ref{fig:convex-hull-kernels}, the origin (marked $\odot$) is marked as `miss', meaning, that it must not be present in the original image.
    As a consequence of that:
    \begin{equation}
        \biggerforall\nolimits_i\biggerforall\nolimits_k \; X^i_k \cap (X^i_k \otimes \mathbf{B}^i) = \emptyset
        \label{eq:convex-hull-disjoint-hmt}
    \end{equation}

    Now, if we substitute the final condition (\ref{eq:convex-hull-final-condition}) to eq.~(\ref{eq:convex-hull-iteration-err}), we get:
    \begin{equation}
        X^i_k = (X^i_k \otimes \mathbf{B}^i) \cup A
        \label{eq:convex-hull-iteration-error-substituted}
    \end{equation}

    Applying $X = X \cap X$, we get
    \begin{align}
        X^i_k & = X^i_k \cap \big((X^i_k \otimes \mathbf{B}^i) \cup A \big) \nonumber    \\
              & = \big(X^i_k \cap (X^i_k \otimes \mathbf{B}^i) \big) \cup (X^i_k \cap A)
    \end{align}

    Applying eq.~(\ref{eq:convex-hull-disjoint-hmt})
    \begin{align}
        X^i_k & = \emptyset \cup (X^i_k \cap A) \nonumber \\
              & = X^i_k \cap A \nonumber                  \\
              & = A \label{eq:convex-hull-only-zero-k}
    \end{align}
    Which is the same as eq.~(\ref{eq:convex-hull-start-condition}), so $k=0$.\\
    Finally, substituting this equation to eq.~(\ref{eq:convex-hull-iteration-error-substituted}), we get
    \begin{equation}
        A = (A \otimes \mathbf{B}^i) \cup A
    \end{equation}

    Which is true if and only if $(A \otimes \mathbf{B}^i) \subseteq A$.\\
    Since $(A \otimes \mathbf{B}^i) \subseteq A$ and from eq.~\eqref{eq:convex-hull-disjoint-hmt}, $(A \otimes \mathbf{B}^i) \cap A = \emptyset$, we have:
    \begin{equation}
        (A \otimes \mathbf{B}^i) = \emptyset
    \end{equation}
    Therefore,
    \begin{align*}
        \bigexists k                              & \iff (A \otimes \mathbf{B}^i) = \emptyset    \\
        \mbox{\large$\mathsurround0pt\nexists$} k & \iff (A \otimes \mathbf{B}^i) \neq \emptyset
    \end{align*}
    Since $\nexists k \Rightarrow \nexists D^i$, we have
    \begin{equation}
        (A \otimes \mathbf{B}^i) \neq \emptyset \implies \mbox{\large$\mathsurround0pt\nexists$} D^i
    \end{equation}
\end{proof}

As the above shows, there are two possibilities of running the algorithm:
\begin{enumerate}
    \item If $\bigforall_i \; (A \otimes \mathbf{B}^i) = \emptyset$, then all $k = 0$ and algorith returns the original image unchanged
    \item Else, the algorithm gets stuck in the infinite loop trying to find $k$ that does not exist
\end{enumerate}

Therefore, we concluded that for the algorithm to work as expected, we must change the eq.~\eqref{eq:convex-hull-iteration-err} to the following:
\begin{equation}
    X^i_k = (X^i_{k-1} \otimes \mathbf{B}^i) \cup X^i_{k-1}
\end{equation}

Now, $k$ will always exist, and it will be such $k$ that $(X^i_k \otimes \mathbf{B}^i) = \emptyset$.

\pagebreak[2]
\subsection{Implementation}
\label{sec:convex-hull-impl}

The implementation can be split into 2 distinct parts.
The first one is calculating $D^i$ for a given $\mathbf{B}^i$.
We will refer to this step as ``saturating'' the image with the hit-or-miss transformation.
The second step is merging all of the resulting images into one.

With standard implementation, we would have to loop over the entire image to calculate the HMT.
Then, we would need to loop again to perform the image union with $X^i_{k-1}$.
This would have to be performed $k$ times for each structuring element.
Finally we would have to loop over the entire image once again to merge all of $D^i$.

However, we are able to perform major optimization by removing the need of applying the union altogether.
We can acomplish this by, instead of using standard HMT, making use of the abovementioned function that returns an iterator to all of the pixels that fullfill the HMT conditions.
We do this by not allocating a clear image buffer for the output of HMT, but instead output the result directy to the image in place.
This firstly, reduces the number of operations significantly, and secondly, drastically reduces the memory complexity, as we will not allocate any aditional buffers.

This also applies to union of $D^i$, because we can redefine the initial conditions from eq.~\eqref{eq:convex-hull-final-condition} as the following:
\begin{equation*}
    X^i_0 =
    \begin{cases}
        A       & \text{for $i = 0$}, \\
        D^{i-1} & \text{for $i > 0$}
    \end{cases}
\end{equation*}

\pagebreak[2]
Below is our implementation of this algorithm:
\begin{lstlisting}
for (hit, miss) in &STRUCTURAL_ELEMENTS {
    let transform = 
        HitOrMissTransform::new(hit.clone(), miss.clone());

    loop {
        let transform_result: Vec<_> = 
            transform.get_matching_pixels(image).collect();
        if transform_result.len() == 0 {
            break;
        }
        for (x, y) in transform_result {
            image.put_pixel(x, y, FOREGROUND_PIXEL);
        }
    }
}
\end{lstlisting}

\section{Analysis of the results of the assigned variant of morphological algorithm}

\begin{figure}[H]\centering
    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image1.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image1-convexhull.png}
        \caption{after}
    \end{subfigure}\\[2em]

    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image2.png}
        \caption{before}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[t]{\subfiguresize}
        \includegraphics[width=\textwidth]{img/image2-convexhull.png}
        \caption{after}
    \end{subfigure}
    \caption{Result of applying the convex hull}
\end{figure}

\section{Description of the implementation of the assigned segmentation variant}
\subsection{Description}
Region growing is a simple region-based image segmentation method that involves starting from a seed point in the image and expanding the region to include neighboring pixels that have similar characteristics to the seed point.
Our implementation uses a breadth-first search algorithm to expand the region from the seed point. It maintains a queue of pixels to visit and adds the neighboring pixels of each pixel to the queue if they have a similar intensity value to the seed point, within a specified tolerance. The resulting image is a binary image with the region of interest marked in white and the rest of the image marked in black.

\subsection{Implementation}

In our implementation, \lstinline{seed_x} and \lstinline{seed_y} represent the $x$ and $y$ coordinates respectively,
of the seed point in the image chosen by the user.
The seed point is also the starting point for the region growing algorithm.
The \lstinline{tolerance} is also chosen by the user.
Firstly, we are checking whether the chosen pixel is within the dimensions of the input image.
If the seed point is within the image dimensions,
the transformation for region growing can be performed.
Below the implementation of the \lstinline{Transformation} trait for \lstinline{RegionGrowing}:

\begin{lstlisting}
    
/* ensure seed_x and seed_y are within image */

let mut new_image: GrayImage = 
    ImageBuffer::new(image.width(), image.height());
let seed_pixel = 
    image.get_pixel(self.seed_x.get(), self.seed_y.get());
let mut queue = VecDeque::new();
queue.push_back((self.seed_x.get(), self.seed_y.get()));

while let Some((x, y)) = queue.pop_front() {
    if x >= image.width() || y >= image.height() {
        continue;
    }
    let pixel = image.get_pixel(x as u32, y as u32);
    let new_image_pixel = new_image.get_pixel(x as u32, y as u32);

    if new_image_pixel[0] == 0 
        && is_similar(pixel, seed_pixel, self.tolerance) {
        new_image.put_pixel(x as u32, y as u32, Luma([255]));

        queue.push_back((x + 1, y));
        queue.push_back((x, y + 1));
        queue.push_back((x - 1, y));
        queue.push_back((x, y - 1));
    }
}
*image = DynamicImage::from(new_image).to_rgb8();
\end{lstlisting}

The \lstinline{is_similar} function was implemented by taking in a reference to a pixel
and a reference to a seed pixel,
as well as a tolerance value.
It calculates the difference between the value of the pixel
and the seed pixel and returns true if the difference is less than or equal
to the tolerance value. Below the implementation of the \lstinline{is_similar} function:

\begin{lstlisting}
fn is_similar(
    pixel: &Rgb<u8>, 
    seed_pixel: &Rgb<u8>, 
    tolerance: u8
) -> bool {
    (pixel[0] as i32 - seed_pixel[0] as i32) <= tolerance as i32
}
\end{lstlisting}

\section{Analysis of the results of the assigned segmentation variant}
\section{Description of other changes which took place in the application}

Your GUI ? <3

\end{document}