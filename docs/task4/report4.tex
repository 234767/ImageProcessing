\documentclass[12pt]{article}

\input{../prelude.tex}
\graphicspath{{img},{../img}}
\renewcommand*{\subfiguresize}{.35\textwidth}

\newcommand*{\fft}{\textsc{fft}}
\newcommand*{\dft}{\textsc{dft}}

\title{Task No.~4}

\begin{document}

\maketitle

\section{Description of the implementation of the assigned transform variant}

We decided to implement the \fft\ using the radix-2 decimation in time variant of the Cooley-Turkey algorithm.
It uses the divide-and-conquer approach to divide a \dft\ of length $N$ into two \dft{}s of length $\frac{N}{2}$.
The speed is gained by reusing some computations for multiple \dft\ outputs.

\begin{figure}[H]\centering
    \begin{tikzpicture}
        \foreach \i in {0,...,7} {
                \node[circle, draw=black, inner sep=0pt, minimum size=2pt](start-\i) at (0,-\i) {};
                \draw[-latex] (start-\i) -- (1,-\i);
                \draw(1,-\i) -- (2,-\i);
            }
        \draw (0, 0) node[left]{$x[0]$};
        \draw (0,-1) node[left]{$x[2]$};
        \draw (0,-2) node[left]{$x[4]$};
        \draw (0,-3) node[left]{$x[6]$};

        \draw (0,-4) node[left]{$x[1]$};
        \draw (0,-5) node[left]{$x[3]$};
        \draw (0,-6) node[left]{$x[5]$};
        \draw (0,-7) node[left]{$x[7]$};

        \draw (2, 0.25) -| ++(2, -3.5) -| cycle;
        \draw (2,-3.75) -| ++(2, -3.5) -| cycle;

        \draw (3,-1.5) node[]{\fft};
        \draw (3,-5.5) node[]{\fft};

        \foreach \i in {0,...,7} {
                \node[circle, draw=black, inner sep=0pt, minimum size=2pt](left-\i) at (5,-\i) {};
                \node[circle, draw=black, inner sep=0pt, minimum size=2pt](right-\i) at (7,-\i) {};
                \draw (7,-\i) node[right]{$X[\i]$};
                \draw[-latex] (4,-\i) -- (left-\i.west);
            }
        \foreach \i in {0,...,3} {
                \pgfmathtruncatemacro{\j}{\i + 4};
                \draw[-latex] (left-\i) node[above left]{\scriptsize$E[\i]$} -- (right-\j);
                \draw[-latex] (left-\j) node[below left]{\scriptsize$O[\i]$}-- (right-\i);
            }
        \foreach \i in {2,...,5} {
                \node[circle, fill=black, inner sep=0pt, minimum size=4pt] at (6,-\i) {};
            }
    \end{tikzpicture}
    \caption{Visualisation of the \fft\ algoritm}
\end{figure}

The algorithm splits the values into even and odd, and then calls itself recursively on each of them.
Finally, it merges the result, using the following formula for $k \in \left\langle 0, \frac{N}{2} \right)$:

\begin{align}
    X_k                 & =  E[k] + e^{-2\pi i\frac{k}{N}} \cdot O[k]  \\
    X_{k + \frac{N}{2}} & =  E[k] - e^{-2\pi i\frac{k}{N}} \cdot  O[k]
\end{align}

It can be noticed that, if the splitting between even and odd, is performed ahead of time, the \fft\ can operate in-place, on the array split in half.

Therefore, our implementation firstly performs the necessary rearranging of values, with new indices created by bit inverses.
Next step is the invocation of the in-place fft, that splits the given array in half, then calls itself recursively on each, and merges the result using abovementioned formulas.

\begin{lstlisting}[
    basicstyle = \footnotesize\ttfamily, 
    caption={Code listing for the \fft\ in-place function}
    ]
fn fft_in_place(data: &mut [Complex<TData>], direction: FTDirection) {
    if data.len() == 1 {
        return;
    }

    let (half_1, half_2) = data.split_at_mut(data.len() / 2);
    fft_in_place(half_1, direction);
    fft_in_place(half_2, direction);

    for i in 0..(data.len() / 2) {
        let angle = match direction {
            Forward => -2.0,
            Inverse => 2.0
        } * PI * i as f64 / data.len() as f64;
        let twiddle_factor = Complex::from_polar(1.0, angle);
        let (a, b) = 
            butterfly_operation(
                &data[i], 
                &data[i + data.len() / 2], 
                twiddle_factor
            );
        data[i] = a;
        data[i + data.len() / 2] = b;
    }
}
\end{lstlisting}

The \lstinline{butterfly_operation} is a helper function, performing the equations mentioned above.
Since they differ only by the sign, we can compute them at the same time to reduce the number of multiplications required.

The main \fft\ function can be then implemented in the following way:
\begin{lstlisting}[
    basicstyle = \footnotesize\ttfamily, 
    caption={Code listing for the \fft\ function}
    ]
pub fn fft<T>(data: &[T], direction: FTDirection) -> Vec<Complex<TData>>
where /* ... */
{
    let mut data: Vec<_> = rearrange_data_for_fft(data)
        .into_iter()
        .map(|x| x * Complex::new(1.0, 0.0))
        .collect();

    fft_in_place(data.as_mut_slice(), direction);
    
    /* handle inverse case ... */

    data
}
\end{lstlisting}

We can see that the only place where we allocate memory is the rearranging of data.
We could not avoid the necessary allocation, because firstly our function is generic, so the initial array could be of different size than needed (e.g.~floats), secondly our API is made such that the function is pure, so we cannot mutate the input value.

Therefore, the memory complexity is $\mathcal{O}(n)$, and computational complexity is $\mathcal{O}(n \log n)$.

The inverse \fft\ is done by changing the sign in the exponential, and dividing all the final values by $N$.

\section{Description of the spectrum visualization method}

To visualize the result, we take the magnitudes of the values, to convert from complex numbers to real ones, and appply logarithmic normalization, according to the following equation:
\begin{equation}
    \hat{T}(x,y) = \frac{255}{\ln(1 + m)} \cdot \ln (1 + T(x,y))
\end{equation}
Where $T$ is the result of the \fft\, and $m = \max\limits_{t \in T}\big\{|t|\big\}$.

This normalization allows us to see the values, which would otherwise be too small.

The result is presented on the figure below.

\begin{figure}[H]\centering
    \begin{subfigure}[ht]{.4\textwidth}\centering
        \includegraphics[width=\textwidth]{lena}
        \caption{Original image}
    \end{subfigure}
    \hspace*{2em}
    \begin{subfigure}[ht]{.4\textwidth}\centering
        \includegraphics[width=\textwidth]{lena_fft}
        \caption{Frequency spectrum}
    \end{subfigure}
    \caption{Image before and after transformation by \fft}
\end{figure}

\section{Description of the implementation of the filters}

When implementing the filters, we noticed the common functionality between them, and decided to extract it.
Each filter can be characterized by the following sequence of actions:

\begin{enumerate}
    \item Apply the fourier transform to the image
    \item Multiply each pixel by corresponding pixel in the mask
    \item Apply the inverse fourier transform
    \item Convert complex numbers to normalized luminosity values
\end{enumerate}

We noticed that the only part of this process that differs for each filter is the mask, which can be thought of as a function $M: (x, y) \mapsto m$, where $x,y \in \mathbb{N}$ and $m \in \langle 0, 1 \rangle$.

Lastly, we focused on the problem of swapping the quadrants of the image in the frequency domain.
Normally we would have to do this process twice --- once before and once after applying the mask.
However, we noticed that we can apply it just once, if instead of swapping quadrants of the image, we perform the swap on the mask.

The conversion from complex values to pixels is trivial, we just take an absolute value and scale it linearly, so that the max value corresponds to the maximum possible luminosity.

The implementation of these steps looks like the following:

\begin{lstlisting}[
    caption={Implementation of the parametrized filter in the frequency domain},
    basicstyle=\footnotesize\ttfamily
]
fn apply_mask_filter<TFourier, TMask>(
    image: &mut RgbImage, 
    mask: &TMask
)
where
    TFourier: ImageFourierTransform,
    TMask: Fn(u32, u32) -> f64,
{
    let mut transform = TFourier::transform(image);
    for (y, row) in transform.iter_mut().enumerate() {
        for (x, pixel) in row.iter_mut().enumerate() {
            let (x, y) =
                swap_coordinates(x, y, image.width(), image.height());
            let mask_value: f64 = mask(x, y);
            *pixel *= mask_value;
        }
    }

    let inverse = TFourier::inverse(&transform);

    let max_value = {
        /* calculate max value ... */
    };

    let result = GrayImage::from_fn(image.width(), image.height(), 
        |x, y| {
            let (x, y) = (x as usize, y as usize);
            let luma = inverse[y][x].abs() / max_value * u8::MAX as f64;
            Luma([luma as u8])
    });

    *image = to_rgb(result);
}
\end{lstlisting}

Finally, all we need to do to implement the specific variants of the filters, is to invoke this function with the appropriate mask (which can be done either by a generator function, or loaded from an image file).

\subsection{Low pass filter}

Low pass filter mask is implemented as a function that takes $(x,y)$ coordinates, and calculates the distance from the center.
If it is greater than some threshold radius $R$, it outputs 1, else 0.

\begin{equation}
    M_R(x,y) = \begin{cases}
        1  &\text{if} \ (x^2 + y^2) \leq R^2 \\
        0  &\text{otherwise}
    \end{cases}
\end{equation}

\subsection{High pass filter}

High pass filter was implemented similarly to the low pass filter, except with the opposite sign.

\begin{equation}
    M_R(x,y) = \begin{cases}
        1  &\text{if} \ (x^2 + y^2) \geq R^2 \\
        0  &\text{otherwise}
    \end{cases}
\end{equation}

\subsection{Band pass filter}

Band pass filter takes 2 values --- $R_1$ and $R_2$ which denote the lower and upper bound of the frequency band.
The filter then blocks any frequency that is not between $R_1$ and $R_2$.

\begin{equation}
    M_{R_1, R_2}(x,y) = \begin{cases}
        1  &\text{if} \ R_1^2 \leq (x^2 + y^2) \leq R_2^2  \\
        0  &\text{otherwise}
    \end{cases}
\end{equation}

\subsection{Band cut filter}

Band cut filter works similarly to the band pass filter, but instead of passing the frequencies that are part of the band, it blocks them and passes everything else.

\begin{equation}
    M_{R_1, R_2}(x,y) = \begin{cases}
        1  &\text{if} \ (x^2 + y^2) \leq R_1^2 \lor (x^2 + y^2) \geq R_2^2  \\
        0  &\text{otherwise}
    \end{cases}
\end{equation}

\section{Analysis of the filtering results}

\subsection{Low pass filter}

\begin{figure}[H]\centering
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena}
        \caption{original}
    \end{subfigure}
    \hspace*{2em}
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena_lowpass}
        \caption{filtered}
    \end{subfigure}
    \caption{Result of applying the low-pass filter with $R \leq 30$}
\end{figure}

\subsection{High pass filter}

\begin{figure}[H]\centering
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena}
        \caption{original}
    \end{subfigure}
    \hspace*{2em}
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena_highpass}
        \caption{filtered}
    \end{subfigure}
    \caption{Result of applying the high-pass filter with $R \geq 30$}
\end{figure}

\subsection{Band pass filter}

\begin{figure}[H]\centering
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena}
        \caption{original}
    \end{subfigure}
    \hspace*{2em}
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena_bandpass}
        \caption{filtered}
    \end{subfigure}
    \caption{Result of applying the band-pass filter with $R \in \langle 10, 50 \rangle$}
\end{figure}

\subsection{Band cut filter}

\begin{figure}[H]\centering
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena}
        \caption{original}
    \end{subfigure}
    \hspace*{2em}
    \begin{subfigure}[ht]{\subfiguresize}
        \includegraphics[width=\textwidth]{lena_bandcut}
        \caption{filtered}
    \end{subfigure}
    \caption{Result of applying the band-cut filter with $R \notin \langle 10, 50 \rangle$}
\end{figure}

\section{Description of other changes which took place in the application}

\vfill
\section*{Teacher's remarks}
\begin{tabularx}{\textwidth}{|X|}
    \hline
    \vspace{7cm}
    \phantom{.} \\
    \hline
\end{tabularx}

\end{document}