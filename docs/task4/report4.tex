\documentclass[12pt]{article}

\input{../prelude.tex}
\graphicspath{{img},{../img}}

\newcommand*{\fft}{\textsc{fft}}
\newcommand*{\dft}{\textsc{dft}}

\title{Task No.~4}

\begin{document}

\maketitle

\section{Description of the implementation of the assigned transform variant}

We decided to implement the \fft\ using the radix-2 decimation in time variant of the Cooley-Turkey algorithm.
It uses the divide-and-conquer approach to divide a \dft\ of length $N$ into two \dft{}s of length $\frac{N}{2}$.
The speed is gained by reusing some computations for multiple \dft\ outputs.

\begin{figure}[H]\centering
    \begin{tikzpicture}
        \foreach \i in {0,...,7} {
                \node[circle, draw=black, inner sep=0pt, minimum size=2pt](start-\i) at (0,-\i) {};
                \draw[-latex] (start-\i) -- (1,-\i);
                \draw(1,-\i) -- (2,-\i);
            }
        \draw (0, 0) node[left]{$x[0]$};
        \draw (0,-1) node[left]{$x[2]$};
        \draw (0,-2) node[left]{$x[4]$};
        \draw (0,-3) node[left]{$x[6]$};

        \draw (0,-4) node[left]{$x[1]$};
        \draw (0,-5) node[left]{$x[3]$};
        \draw (0,-6) node[left]{$x[5]$};
        \draw (0,-7) node[left]{$x[7]$};

        \draw (2, 0.25) -| ++(2, -3.5) -| cycle;
        \draw (2,-3.75) -| ++(2, -3.5) -| cycle;

        \draw (3,-1.5) node[]{\fft};
        \draw (3,-5.5) node[]{\fft};

        \foreach \i in {0,...,7} {
                \node[circle, draw=black, inner sep=0pt, minimum size=2pt](left-\i) at (5,-\i) {};
                \node[circle, draw=black, inner sep=0pt, minimum size=2pt](right-\i) at (7,-\i) {};
                \draw (7,-\i) node[right]{$X[\i]$};
                \draw[-latex] (4,-\i) -- (left-\i.west);
            }
        \foreach \i in {0,...,3} {
                \pgfmathtruncatemacro{\j}{\i + 4};
                \draw[-latex] (left-\i) node[above left]{\scriptsize$E[\i]$} -- (right-\j);
                \draw[-latex] (left-\j) node[below left]{\scriptsize$O[\i]$}-- (right-\i);
            }
        \foreach \i in {2,...,5} {
                \node[circle, fill=black, inner sep=0pt, minimum size=4pt] at (6,-\i) {};
            }
    \end{tikzpicture}
    \caption{Visualisation of the \fft\ algoritm}
\end{figure}

The algorithm splits the values into even and odd, and then calls itself recursively on each of them.
Finally, it merges the result, using the following formula for $k \in \left\langle 0, \frac{N}{2} \right)$:

\begin{align}
    X_k                 & =  E[k] + e^{-2\pi i\frac{k}{N}} \cdot O[k]  \\
    X_{k + \frac{N}{2}} & =  E[k] - e^{-2\pi i\frac{k}{N}} \cdot  O[k]
\end{align}

It can be noticed that, if the splitting between even and odd, is performed ahead of time, the \fft\ can operate in-place, on the array split in half.

Therefore, our implementation firstly performs the necessary rearranging of values, with new indices created by bit inverses.
Next step is the invocation of the in-place fft, that splits the given array in half, then calls itself recursively on each, and merges the result using abovementioned formulas.

\begin{lstlisting}[
    basicstyle = \footnotesize\ttfamily, 
    caption={Code listing for the \fft\ in-place function}
    ]
fn fft_in_place(data: &mut [Complex<TData>], direction: FTDirection) {
    if data.len() == 1 {
        return;
    }

    let (half_1, half_2) = data.split_at_mut(data.len() / 2);
    fft_in_place(half_1, direction);
    fft_in_place(half_2, direction);

    for i in 0..(data.len() / 2) {
        let angle = match direction {
            Forward => -2.0,
            Inverse => 2.0
        } * PI * i as f64 / data.len() as f64;
        let twiddle_factor = Complex::from_polar(1.0, angle);
        let (a, b) = 
            butterfly_operation(
                &data[i], 
                &data[i + data.len() / 2], 
                twiddle_factor
            );
        data[i] = a;
        data[i + data.len() / 2] = b;
    }
}
\end{lstlisting}

The \lstinline{butterfly_operation} is a helper function, performing the equations mentioned above.
Since they differ only by the sign, we can compute them at the same time to reduce the number of multiplications required.

The main \fft\ function can be then implemented in the following way:
\begin{lstlisting}[
    basicstyle = \footnotesize\ttfamily, 
    caption={Code listing for the \fft\ function}
    ]
pub fn fft<T>(data: &[T], direction: FTDirection) -> Vec<Complex<TData>>
where /* ... */
{
    let mut data: Vec<_> = rearrange_data_for_fft(data)
        .into_iter()
        .map(|x| x * Complex::new(1.0, 0.0))
        .collect();

    fft_in_place(data.as_mut_slice(), direction);
    
    /* handle inverse case ... */

    data
}
\end{lstlisting}

We can see that the only place where we allocate memory is the rearranging of data.
We could not avoid the necessary allocation, because firstly our function is generic, so the initial array could be of different size than needed (e.g.~floats), secondly our API is made such that the function is pure, so we cannot mutate the input value.

Therefore, the memory complexity is $\mathcal{O}(n)$, and computational complexity is $\mathcal{O}(n \log n)$.

The inverse \fft\ is done by changing the sign in the exponential, and dividing all the final values by $N$. 

\section{Description of the spectrum visualization method}

To visualize the result, we take the magnitudes of the values, to convert from complex numbers to real ones, and appply logarithmic normalization, according to the following equation:
\begin{equation}
    \hat{T}(x,y) = \frac{255}{\ln(1 + m)} \cdot \ln (1 + T(x,y))
\end{equation}
Where $T$ is the result of the \fft\, and $m = \max\limits_{t \in T}\big\{|t|\big\}$.

This normalization allows us to see the values, which would otherwise be too small.

The result is presented on the figure below.

\begin{figure}[H]\centering
    \begin{subfigure}[ht]{.4\textwidth}\centering
        \includegraphics[width=\textwidth]{lena}
        \caption{Original image}
    \end{subfigure}
    \hspace*{2em}
    \begin{subfigure}[ht]{.4\textwidth}\centering
        \includegraphics[width=\textwidth]{lena_fft}
        \caption{Frequency spectrum}
    \end{subfigure}
    \caption{Image before and after transformation by \fft}
\end{figure}

\section{Description of the implementation of the filters}

\section{Analysis of the filtering results}

\section{Description of other changes which took place in the application}

\vfill
\section*{Teacher's remarks}
\begin{tabularx}{\textwidth}{|X|}
    \hline
    \vspace{7cm}
    \phantom{.} \\
    \hline
\end{tabularx}

\end{document}